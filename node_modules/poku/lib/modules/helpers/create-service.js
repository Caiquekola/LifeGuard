"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.startScript = exports.startService = void 0;
const node_process_1 = __importDefault(require("process"));
const node_child_process_1 = require("child_process");
const get_runner_js_1 = require("../../parsers/get-runner.js");
const node_path_1 = require("path");
const list_files_js_1 = require("./list-files.js");
const kill_js_1 = require("./kill.js");
const write_js_1 = require("../../services/write.js");
const runningProcesses = new Map();
const backgroundProcess = (runtime, args, file, options) => new Promise((resolve, reject) => {
    try {
        let isResolved = false;
        const service = (0, node_child_process_1.spawn)(runtime, args, {
            stdio: ['inherit', 'pipe', 'pipe'],
            env: node_process_1.default.env,
            timeout: options === null || options === void 0 ? void 0 : options.timeout,
            cwd: (options === null || options === void 0 ? void 0 : options.cwd) ? (0, list_files_js_1.sanitizePath)((0, node_path_1.normalize)(options.cwd)) : undefined,
            shell: get_runner_js_1.isWindows,
            detached: !get_runner_js_1.isWindows,
            windowsHide: get_runner_js_1.isWindows,
        });
        const PID = service.pid;
        let portBackup;
        const end = (port) => new Promise((resolve) => {
            try {
                runningProcesses.delete(PID);
                if (get_runner_js_1.isWindows) {
                    kill_js_1.kill.pid(PID);
                    return;
                }
                if (['bun', 'deno'].includes(runtime) ||
                    ['bun', 'deno'].includes(String(options === null || options === void 0 ? void 0 : options.runner))) {
                    node_process_1.default.kill(PID);
                }
                else {
                    node_process_1.default.kill(-PID, 'SIGKILL');
                }
                if (port && ['bun', 'deno'].includes(runtime)) {
                    setTimeout(async () => {
                        await kill_js_1.kill.port(port);
                        resolve(undefined);
                        return;
                    });
                }
                else {
                    resolve(undefined);
                    return;
                }
            }
            catch (_a) {
                resolve(undefined);
                return;
            }
        });
        runningProcesses.set(PID, { end, port: portBackup });
        service.stdout.on('data', (data) => {
            if (!isResolved && typeof (options === null || options === void 0 ? void 0 : options.startAfter) !== 'number') {
                const stringData = JSON.stringify(String(data));
                if (typeof (options === null || options === void 0 ? void 0 : options.startAfter) === 'undefined' ||
                    (typeof (options === null || options === void 0 ? void 0 : options.startAfter) === 'string' &&
                        stringData.includes(options === null || options === void 0 ? void 0 : options.startAfter))) {
                    resolve({ end });
                    clearTimeout(timeout);
                    isResolved = true;
                }
            }
            (options === null || options === void 0 ? void 0 : options.verbose) && write_js_1.Write.log(data);
        });
        service.stderr.on('data', (data) => {
            if (!isResolved && typeof (options === null || options === void 0 ? void 0 : options.startAfter) !== 'number') {
                const stringData = JSON.stringify(String(data));
                if (typeof (options === null || options === void 0 ? void 0 : options.startAfter) === 'undefined' ||
                    (typeof (options === null || options === void 0 ? void 0 : options.startAfter) === 'string' &&
                        stringData.includes(options === null || options === void 0 ? void 0 : options.startAfter))) {
                    resolve({ end });
                    clearTimeout(timeout);
                    isResolved = true;
                }
            }
            (options === null || options === void 0 ? void 0 : options.verbose) && write_js_1.Write.log(data);
        });
        service.on('error', (err) => {
            end(portBackup);
            reject(`Service failed to start: ${err}`);
        });
        service.on('close', (code) => {
            if (code !== 0) {
                reject(`Service exited with code ${code}`);
            }
        });
        const timeout = setTimeout(() => {
            if (!isResolved) {
                end(portBackup);
                reject(`createService: Timeout\nFile: ${file}`);
            }
        }, (options === null || options === void 0 ? void 0 : options.timeout) || 60000);
        if (typeof (options === null || options === void 0 ? void 0 : options.startAfter) === 'number') {
            setTimeout(() => {
                if (!isResolved) {
                    resolve({ end });
                    clearTimeout(timeout);
                    isResolved = true;
                }
            }, options.startAfter);
        }
    }
    catch (_a) { }
});
/** Starts a file in a background process (useful for servers, APIs, etc.) */
const startService = async (file, options) => {
    const runtimeOptions = (0, get_runner_js_1.runner)(file, { platform: options === null || options === void 0 ? void 0 : options.platform });
    const runtime = runtimeOptions.shift();
    const runtimeArgs = [...runtimeOptions, file];
    return await backgroundProcess(runtime, runtimeArgs, (0, node_path_1.normalize)((0, list_files_js_1.sanitizePath)(file)), options);
};
exports.startService = startService;
/**
 *
 * Starts a script (package.json) or task (deno.json) in a background process (useful for servers, APIs, etc.).
 *
 * ---
 *
 * By default, it uses **npm**, but you can costumize it using the `runner` option.
 */
const startScript = async (script, options) => {
    const runner = (options === null || options === void 0 ? void 0 : options.runner) || 'npm';
    const runtimeOptions = (0, get_runner_js_1.scriptRunner)(runner);
    const runtime = runtimeOptions.shift();
    const runtimeArgs = [...runtimeOptions, script];
    return await backgroundProcess(runtime, runtimeArgs, script, {
        ...options,
        runner,
    });
};
exports.startScript = startScript;
node_process_1.default.once('SIGINT', async () => {
    for (const { end, port } of runningProcesses.values()) {
        await end(port);
    }
});
